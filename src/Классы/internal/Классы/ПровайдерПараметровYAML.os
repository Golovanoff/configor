#Использовать logos
#Использовать semver

Перем Лог;

#Область ПрограммныйИнтерфейс

// Возвращает приоритет провайдера
//
//  Возвращаемое значение:
//   Число - текущий приоритет провайдера
//
Функция Приоритет() Экспорт
	Возврат 1;
КонецФункции

// Возвращает идентификатор провайдера
//
//  Возвращаемое значение:
//   Строка - текущий идентификатор провайдера
//
Функция Идентификатор() Экспорт
	Возврат "yaml";
КонецФункции

// Возвращает тип провайдера
//
//  Возвращаемое значение:
//   Строка - текущий тип провайдера
//
Функция ТипПровайдера() Экспорт
	Возврат "file";
КонецФункции

// Возвращает расширения файлов по умолчанию
//
//  Возвращаемое значение:
//   Строка - расширения файлов по умолчанию (yaml yml)
//
Функция РасширенияФайлов() Экспорт
	Возврат "yaml yml";
КонецФункции

// Выполняет чтение параметров для провайдера
//
// Параметры:
//   НастройкиПровайдера - Структура - структура настроек провайдера
//
//  Возвращаемое значение:
//   Соответствие - результат чтения провайдера
//
Функция ПрочитатьПараметры(Знач НастройкиПровайдера) Экспорт

	ПрочитанныеПараметры = Новый Соответствие;

	Лог.Отладка("Чтение параметров из файлов <yaml> не реализовано");

	ПодключитьDLL();

	ПроцессорЧтения = Новый YamlПроцессорYamlDotNet;


	Возврат ПрочитанныеПараметры;

КонецФункции

#КонецОбласти

#Область Упакованные_dll

Процедура РаспаковатьДанныеDLL(Знач ПутьКФайлу, ДанныеDLL)
	
	ДвоичныеДанные = Base64Значение(ДанныеDLL.ДвоичныеДанные());
	ДвоичныеДанные.Записать(ПутьКФайлу);

КонецПроцедуры

Функция ВычислитьХешФайла(Знач ПутьКФайлу)

	ХешФайла = Новый ХешированиеДанных(ХешФункция.MD5);
	ХешФайла.ДобавитьФайл(ПутьКФайлу);

 	Возврат ХешФайла.ХешСуммаСтрокой;
	
КонецФункции

Процедура ПодключитьDLL()
	
	ЗапакованныеДанные = ПолучитьДанныеDLL();

	ЧитательYaml = ЗапакованныеДанные.YamlDotNet;

	Если ЧитательYaml = Неопределено Тогда
		ВызватьИсключение "Не удалось найти библиотеку чтения файлов <yaml>";
	КонецЕсли;	

	НайтиФайлИлиРаспаковать(ЧитательYaml);
	
	ДополнительнаяБиблиотека = ЗапакованныеДанные.YamlDotNetProcessor;

	Если ДополнительнаяБиблиотека = Неопределено Тогда
		ВызватьИсключение "Не удалось найти библиотеку чтения файлов <yaml>";
	КонецЕсли;	

	НайтиФайлИлиРаспаковать(ДополнительнаяБиблиотека);

	ПутьКФайлу = ПолучитьПутьКФайлуDLL(ЧитательYaml.ИмяФайла(), ЧитательYaml.Версия());

	ПодключитьВнешнююКомпоненту(ПутьКФайлу);

КонецПроцедуры

Процедура НайтиФайлИлиРаспаковать(ДанныеDLL)
	
	ИмяФайла = ДанныеDLL.ИмяФайла();
	
	ПутьКФайлу = ПолучитьПутьКФайлуDLL(ИмяФайла, ДанныеDLL.Версия());

	ВременныйФайл = Новый Файл(ПутьКФайлу);

	Если Не ВременныйФайл.Существует() 
		ИЛИ Не ВычислитьХешФайла(ПутьКФайлу) = ДанныеDll.Хеш() Тогда
		РаспаковатьДанныеDLL(ПутьКФайлу, ДанныеDLL);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьПутьКФайлуDLL(ИмяФайла, ВерсияФайла)
	ПутьКФайлу = ОбъединитьПути(КаталогВременныхФайлов(), ".configor", СтрЗаменить(ВерсияФайла, ".", "_"), ИмяФайла);
	Возврат ПутьКФайлу;
КонецФункции

Функция ПолучитьДанныеDLL()
	
	СИ = Новый СистемнаяИнформация;
	ТекущаяВерсия = Новый Версия(СИ.Версия);

	ИндексВерсийДЛЛ = Новый Соответствие;
	ИндексВерсийДЛЛ.Вставить("1.0.0", ">=1.0.19");

	МассивПодходящихВерсийДЛЛ = Новый Массив;

	Для каждого ВерсияПроверки Из ИндексВерсийДЛЛ Цикл
		
		ДиапазонСравнения = ВерсияПроверки.Значение;
		ВерсияПроверкиДЛЛ = ВерсияПроверки.Ключ;
		Результат = Версии.ВерсияВДиапазоне(ТекущаяВерсия, ДиапазонСравнения);

		Если Результат Тогда
			МассивПодходящихВерсийДЛЛ.Добавить(ВерсияПроверкиДЛЛ);
		КонецЕсли;

	КонецЦикла;

	ВерсияДЛЛ = Версии.МаксимальнаяИзМассива(МассивПодходящихВерсийДЛЛ).ВСтроку();
	
	МенеджерЗапакованныхФайлов = Новый МенеджерЗапакованныхФайлов;

	YamlDotNet = МенеджерЗапакованныхФайлов.ПолучитьКлассФайла("YamlDotNet.dll", ВерсияДЛЛ);
	YamlDotNetProcessor = МенеджерЗапакованныхФайлов.ПолучитьКлассФайла("YamlDotNet.dll", ВерсияДЛЛ);
	ДанныеDLL = Новый Структура("YamlDotNet, YamlDotNetProcessor", YamlDotNet, YamlDotNetProcessor);

	Возврат ДанныеDLL;

КонецФункции

#КонецОбласти

Лог = Логирование.ПолучитьЛог("oscript.lib.configor.yaml");